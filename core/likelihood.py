# Imports:import numpy as np# Public functions:__all__ = ['gauss']# Define log(2*pi) as constant.log2pi = 1.8378770664093453# Listing: 01def gauss(m, S, sde_struct):    """        GAUSSIAN OBSERVATION LIKELIHOOD        [Description]    This module computes the observation related energy terms along with    the derivatives with respect the marginal mean and covariance values.        [Input]    m     : marginal   means   (N x D).    S     : marginal variances (N x D).    sde_struct : Data structure (dictionary) that holds model parameters.        [Output]    Eobs     : energy term from the observation likelihood     (1 x 1).    dEobs_dm : derivative of Eobs with respect to m(t)         (N x D).    dEobs_dS : derivative of Eobs with respect to S(t)     (N x D x D).    dEobs_dR : derivative of Eobs with respect to R        (N x d x d).        Copyright (c) Michail D. Vrettas, PhD - November 2015.        Last Updated: August 2016.        Contact:      If you find any bug or have any suggestions,      please contact me at: <vrettasm@gmail.com>        Webpage:      The code can be downloaded from:      <http://vrettasm.weebly.com/software.html>    """        # Call and return the right version.    if (sde_struct['D'] == 1):        return gauss_1D(m, S, sde_struct)    else:        return gauss_nD(m, S, sde_struct)# Listing: 02def gauss_1D(m, S, sde_struct):    """        Gaussian likelihood: 1D    """        # Extract the observations.    Y = sde_struct['obsY']        # Extract the observations.    idx = sde_struct['obsX']        # Get the dimensions of the problem    N = sde_struct['N']        # Get the total number of observations.    M = Y.shape[0]        # Observation matrix    H = sde_struct['H']        # Precompute this only once.    W = (Y - H*np.take(m, idx, axis=0))        # Observation noise    R = sde_struct['Rig']        # Invert.    Ri = 1.0/R        # Gradients of Eobs w.r.t. marginal m(t) and S(t).    dEobs_dm = np.zeros((N,1), dtype='float64')    dEobs_dS = np.zeros((N,1), dtype='float64')        # Second order Gaussian Moments.    Ex2 = m**2 + S        # Energy from the observations.    Eobs = 0.5*Ri*np.sum(Y**2 - 2*Y*m[idx] + Ex2[idx]) +\                                0.5*M*(log2pi + np.log(R))        # Jumps -Eq(31)- NOT IN THE PAPER.    dEobs_dm[idx] = -Ri*W        # Jumps -Eq(32)- NOT IN THE PAPER.    dEobs_dS[idx] = 0.5*Ri        # Preallocate array.    dEobs_dR = np.zeros((N,1), dtype='float64')        # Calculate the gradient at 'M' observation times.    dEobs_dR[idx] = -0.5*Ri*(Y**2 - 2*Y*m[idx] + Ex2[idx]) + 0.5*Ri        # Exit:    return Eobs, dEobs_dm, dEobs_dS, dEobs_dR# Listing: 03def gauss_nD(m, S, sde_struct):    """        Gaussian likelihood: nD    """        # Extract the observations.    Y = sde_struct['obsY']        # Get the dimensions of the problem    N = sde_struct['N']    D = sde_struct['D']        # Obesrvation matrix    H = sde_struct['H']        # Observation indexes.    idx = sde_struct['obsX']        # Observation noise    R = sde_struct['Rig']        # Get the dimensions of the observations.    M, d = Y.shape        # Precompute this only once.    W = (Y - np.take(m, idx, axis=0).dot(H))        # Inverted Cholesky factor.    Ri, Qi = chol_inv(R)        # Extract the diagonal elements.    diag_Ri = Ri.diagonal()        # Precompute this only once.    Z = W.dot(Qi.T)        # Energy from the observations.    Eobs = 0.0        # Preallocate memory for the gradients.    dEobs_dm = np.zeros((N,D),  dtype='float64')    dEobs_dS = np.zeros((N,D,D),dtype='float64')        # Calculate the "E_{obs}".    for n in range(M):        # Get the index of the n-th observation        tn = idx[n]                # Self explained.        Zn = Z[n,:]                # Self explained.        diag_Sn = S[tn,:,:].diagonal()                # Sum the energy iteratively        Eobs += Zn.T.dot(Zn) + diag_Ri.dot(diag_Sn.T)                # Gradient of E_{obs} w.r.t. m(tn)        dEobs_dm[tn,:] = -H.T.dot(Ri).dot(W[n,:])                # Gradient of E_{obs} w.r.t. S(tn)        dEobs_dS[tn,:,:] = 0.5*H.T.dot(Ri).dot(H)    #_end_for        # Compute the final including the constants.    Eobs = 0.5*(Eobs + M*(d*log2pi + log_det(R)))        # Preallocate array.    dEobs_dR = np.zeros((N,d), dtype='float64')        # Return values.    return Eobs, dEobs_dm, dEobs_dS, dEobs_dR# End_Of_File