# Imports:import numpy as npfrom auxiliary.numerical import *# Public functions:__all__ = ['gauss']# Define log(2*pi) as constant.log2pi = 1.8378770664093453# Listing: 01def gauss(m, S, sde_struct):    """        GAUSSIAN OBSERVATION LIKELIHOOD    [Description]    This module computes the observation related energy terms along with    the derivatives with respect the marginal mean and covariance values.    [Input]    m     : marginal   means   (N x D).    S     : marginal variances (N x D).    sde_struct : Data structure (dictionary) that holds model parameters.    [Output]    Eobs     : energy term from the observation likelihood     (1 x 1).    dEobs_dm : derivative of Eobs with respect to m(t)         (N x D).    dEobs_dS : derivative of Eobs with respect to S(t)     (N x D x D).    dEobs_dR : derivative of Eobs with respect to R        (N x d x d).    Copyright (c) Michail D. Vrettas, PhD - November 2015.    Last Updated: August 2016.    Contact:      If you find any bug or have any suggestions,      please contact me at: <vrettasm@gmail.com>    Webpage:      The code can be downloaded from:      <http://vrettasm.weebly.com/software.html>    """    # Call and return the right version.    if (sde_struct['D'] == 1):        return gauss_1D(m, S, sde_struct)    else:        return gauss_nD(m, S, sde_struct)# Listing: 02def gauss_1D(m, S, sde_struct):    """        Gaussian likelihood: 1D    """    # Extract the observations.    Y = sde_struct['obsY']    # Extract the observations.    idx = sde_struct['obsX']    # Get the dimensions of the problem    N = sde_struct['N']    # Get the total number of observations.    M = Y.shape[0]    # Observation matrix    H = sde_struct['H']    # Precompute this only once.    W = (Y - H*np.take(m, idx, axis=0))    # Observation noise    R = sde_struct['Rig']    # Invert.    Ri = 1.0/R    # Gradients of Eobs w.r.t. marginal m(t) and S(t).    dEobs_dm = np.zeros((N,1), dtype='float64')    dEobs_dS = np.zeros((N,1), dtype='float64')    # Second order Gaussian Moments.    Ex2 = m**2 + S    # Energy from the observations.    Eobs = 0.5*Ri*np.sum(Y**2 - 2*Y*m[idx] + Ex2[idx]) +\                                0.5*M*(log2pi + np.log(R))    # Jumps -Eq(31)- NOT IN THE PAPER.    dEobs_dm[idx] = -Ri*W    # Jumps -Eq(32)- NOT IN THE PAPER.    dEobs_dS[idx] = 0.5*Ri    # Preallocate array.    dEobs_dR = np.zeros((N,1), dtype='float64')    # Calculate the gradient at 'M' observation times.    dEobs_dR[idx] = -0.5*Ri*(Y**2 - 2*Y*m[idx] + Ex2[idx]) + 0.5*Ri    # Exit:    return Eobs, dEobs_dm, dEobs_dS, dEobs_dR# Listing: 03def gauss_nD(m, S, sde_struct):    """        Gaussian likelihood: nD    """    # Extract the observations.    Y = sde_struct['obsY']    # Get the dimensions of the problem    N = sde_struct['N']    D = sde_struct['D']    # Obesrvation matrix    H = sde_struct['H']    # Observation indexes.    idx = sde_struct['obsX']    # Observation noise    R = sde_struct['Rig']    # Get the dimensions of the observations.    M, d = Y.shape    # Precompute this only once.    W = (Y - np.take(m, idx, axis=0).dot(H))    # Inverted Cholesky factor.    Ri, Qi = chol_inv(R)    # Extract the diagonal elements.    diag_Ri = Ri.diagonal()    # Precompute this only once.    Z = W.dot(Qi.T)    # Energy from the observations.    Eobs = 0.0    # Preallocate memory for the gradients.    dEobs_dm = np.zeros((N,D),  dtype='float64')    dEobs_dS = np.zeros((N,D,D),dtype='float64')    # Calculate the "E_{obs}".    for n in range(M):        # Get the index of the n-th observation        tn = idx[n]        # Self explained.        Zn = Z[n,:]        # Self explained.        diag_Sn = S[tn,:,:].diagonal()        # Sum the energy iteratively        Eobs += Zn.T.dot(Zn) + diag_Ri.dot(diag_Sn.T)        # Gradient of E_{obs} w.r.t. m(tn)        dEobs_dm[tn,:] = -H.T.dot(Ri).dot(W[n,:])        # Gradient of E_{obs} w.r.t. S(tn)        dEobs_dS[tn,:,:] = 0.5*H.T.dot(Ri).dot(H)    #_end_for    # Compute the final including the constants.    Eobs = 0.5*(Eobs + M*(d*log2pi + log_det(R)))    # Preallocate array.    dEobs_dR = np.zeros((N,d), dtype='float64')    # Return values.    return Eobs, dEobs_dm, dEobs_dS, dEobs_dR# End_Of_File